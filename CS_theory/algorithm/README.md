# 1. 자료구조
## 1. 배열과 리스트
### 배열
- 배열 : 메모리의 연속 공간에 값이 채워져 있는 형태의 자료구조
- 배열의 특징 
   1. 인덱스를 사용하여 값에 바로 접근할 수 있음
   2. 새로운 값을 삽입하거나 특정 인덱스에 있는 값을 삭제하기 어려움. 값을 삽입하거나 삭제하려면 해당 인덱스 주변에 있는 값을 이동시키는 과정이 필요함
   3. 배열의 크기는 선언할 때 지정할 수 있으며 한 번 선언하면 크기를 늘리거나 줄일 수 없음
   4. 구조 간단
   
### 리스트
- 리스트 : 값과 포인터를 묶은 노드라는 것을 포인터로 연결한 자료구조
  - 노드 : 컴퓨터 과학에서 값, 포인터를 쌍으로 갖는 기초 단위를 부르는 말
- 리스트의 특징
   1. 인덱스가 없으므로 값에 접근하려면 head 포인터부터 순서대로 접근해야 함 (값에 접근하는 속도가 느리다.)
   2. 포인터로 연결되어 있으므로 데이터를 삽입하거나 삭제하는 연산속도가 빠름
   3. 선언할 때 크기를 별도롤 지정하지 않아도 됨. 리스트의 크기는 정해져 있지 않으며 크기가 변하기 쉬운 데이터를 다룰 때 적절함
   4. 배열보다 구조가 복잡함(포인터를 저장할 공간이 필요해서)
   
> 파이썬에서는 배열과 리스트를 구분하지 않음

## 2. 구간 합
- 구간 합 : 합 배열을 이용하여 시간 복잡도를 더 줄이기 위해 사용하는 특수한 목적의 알고리즘
- 합 배열 S를 만드는 공식 : S[i]=S[i-1]+A[i]
- 구간 합을 구하는 공식 : S[j]-S[i-1]
- 2차원 구간 D[i][j]의 값을 채우는 구간 합 공식
  - D[i][j] = D[i][j-1]+D[i-1][j]-D[i-1][j-1]+A[i][j]
- X<sub>1</sub>, Y<sub>1</sub>, X<sub>2</sub>, Y<sub>2</sub>에 대한 답을 구간 합으로 구하는 방법
  - D[X2][Y2]-D[X1-1][Y2]-D[X2][Y1-1]+D[X1-1][Y1-1]
  
## 3. 투포인터
- 투포인터 : 2개의 포인터로 알고리즘의 시간 복잡도를 최적화함
- 투포인터 이동 원칙
  - sum > N: sum=sum-start_index; start_index++;
  - sum < N: end_index++; sum=sum+end_index;
  - sum== N: end_index++; sum=sum+end_index; count++;
  
## 4. 슬라이딩 윈도우
- 슬라이딩 윈도우 알고리즘 : 2개의 포인터로 범위를 지정한 다음, 범위를 유지한 채로 이동하여 문제를 해결함


## 5. 스택과 큐
- 스택과 큐 : 리스트에서 조금 더 발전한 형태의 자료구조

### 스택과 큐의 핵심 이론
#### 스택
- 스택 : 삽입과 삭제 연산이 후입선출로 이뤄지는 자료구조
  - 후입선출 : 삽입과 삭제가 한 쪽에서만 일어나는 특징이 있음
    - 가장 마지막에 넣었던 값이 나오게 되는 것
    - 후입선출 개념 자체가 재귀 함수 알고리즘 원리와 일맥상통함
  - **깊이 우선 탐색**, **백트래킹 종류**의 코딩 테스트에 효과적임
  
- 파이썬의 스택(리스트로 구현할 수 있음)
  - 위치
    - top : 삽입과 삭제가 일어나는 위치를 뜻함
  - 연산(리스트 이름이 s일때)
    - s.append(data) : top 위치에 새로운 데이터를 삽입하는 연산
    - s.pop() : top 위치에 현재 있는 데이터를 삭제하고 확인하는 연산
    - s[-1] : top 위치에 현재 있는 데이터를 단순 확인하는 연산

#### 큐
- 큐: 삽입과 삭제 연산이 선입선출로 이뤄지는 자료구조
  - 스택과 다르게 먼저 들어온 데이터가 먼저 나감
  - 삽입과 삭제가 양방향에서 이뤄짐
  - 너비 우선 탐색에서 자주 사용
  
- 파이썬의 큐(deque를 이용)
  - 위치
    - rear : 큐에서 가장 끝 데이터를 가리키는 영역
    - front : 큐에서 가장 앞의 데이터를 가리키는 영역
  - 연산(리스트 이름이 s일때)
    - s.append(data) : rear 부분에 새로운 데이터를 삽입하는 연산
    - s.popleft() : front 부분에 있는 데이터를 삭제하고 확인하는 연산
    - s[0] : 큐의 맨 앞(front)에 있는 데이터를 확인할 때 사용하는 연산
 
~~~
우선순위 큐도 있음
- 우선순위 큐: 값이 들어간 순서와 상관 없이 우선순위가 높은 데이터가 먼저 나오는 자료구조
  - 큐 설정에 따라 front에 항상 최댓값과 최솟값이 위치함
  - 일반적으로 힙을 이용해 구현
  - 힙은 트리 종류 중 하나
~~~  


# 2. 정렬

|정렬 알고리즘|정의|
|------------|----|
|버블(bubble)|데이터의 인접 요소끼리 비교하고 swap 연산을 수행하며 정렬하는 방식|
|삽입(selection)|대상에서 가장 크거나 작은 데이터를 찾아가 선택을 반복하면서 정렬하는 방식|
|삽입(insertion)|대상을 선택해 정렬된 영역에서 선택 데이터의 적절한 위치를 찾아 삽입하면서 정렬하는 방식|
|퀵(quick)|pivot 값을 선정해 해당 값을 기준으로 정렬하는 방식|
|병합(merge)|이미 정렬된 부분 집합들을 효율적으로 병합해 전체를 정렬하는 방식|
|기수(radix)|데이터의 자릿수를 바탕으로 비교해 데이터를 정렬하는 방식|

## 1. 버블 정렬
- 버블 정렬 : 두 인접한 데이터의 크기를 비교해 정렬하는 방법
  - 시간 복잡도 : O(n<sup>2</sup>)-> 다른 정렬 알고리즘보다 속도가 느린 편
  - 루프를 돌면서 인접한 데이터 간의 swap 연산으로 정렬함
- 버블 정렬 과정
   1. 비교 연산이 필요한 루프 범위를 설정함
   2. 인접한 데이터 값을 비교함
   3. swap 조건에 부합하면 swap 연산을 수행함
   4. 루프 범위가 끝날 때까지 2,3을 반복함
   5. 정렬 영역을 설정한다. 다음 루프를 실행할 때는 이 영역을 제외함
   6. 비교 대상이 없을 때까지 1~5를 반복함
   
## 2. 선택 정렬
- 선택 정렬 : 대상 데이터에서 최대나 최소 데이터를 데이터가 나열된 순으로 찾아가며 선택하는 방법
  - 구현 방법이 복잡
  - 시간 복잡도 : O(n<sup>2</sup>) -> 효율적이지 않아 코딩 테스트에서는 사용하지 않음

- 선택 정렬의 핵심 이론
  - 최솟값 또는 최댓값을 찾고 남은 정렬 부분의 가장 앞에 있는 데이터와 swap하는 것이 핵심
  
- 선택 정렬 과정
   1. 남은 정렬 부분에서 최솟값 또는 최댓값을 찾음
   2. 남은 정렬 부분에서 가장 앞에 있는 데이터와 선택된 데이터를 swap함
   3. 가장 앞에 있는 데이터의 위치를 변경해 남은 정렬 부분의 범위를 축소함
   4. 전체 데이터 크기만큼 index가 커질 때까지, 즉 남은 정렬 부분이 없을 때까지 반복함.
   

## 3. 삽입 정렬
- 삽입 정렬 : 이미 정렬된 데이터 범위에 정렬되지 않은 데이터를 적절한 위치에 삽입시켜 정렬하는 방식
  - 시간 복잡도 : O(n<sup>2</sup>) -> 느린 편이지만 구현하기 쉬움

- 삽입 정렬의 핵심 이론 : 선택 데이터를 현재 정렬된 데이터 범위 내에서 적절한 위치에 삽입하는 것이 핵심

- 삽입 정렬 수행 방식
   1. 현재 index에 있는 데이터 값을 선택함
   2. 현재 선택한 데이터가 정렬된 데이터 범위에 삽입될 위치를 탐색함
   3. 삽입 위치부터 index에 있는 위치까지 shift 연산을 수행함
   4. 삽입 위치에 현재 선택한 데이터를 삽입하고 index++ 연산을 수행함
   5. 전체 데이터의 크기만큼 index가 커질 때까지, 즉 선택할 데이터가 없을 때까지 반복함
 
 - 적절한 삽입 위치를 탐색하는 부분에서 이진 탐색 등과 같은 탐색 알고리즘을 사용하면 시간 복잡도를 줄일 수 있음
 
 ## 4. 퀵 정렬
 - 퀵 정렬 : 기준값(pivot)을 선정해 해당 값보다 작은 데이터와 큰 데이터로 분류하는 것을 반복해 정렬하는 알고리즘
   - 기준값이 어떻게 선정되는지가 시간 복잡도에 많은 영향을 미침
     - 평균적인 시간 복잡도 : O(nlogn)
     - 최악의 경우의 시간 복잡도 : O(n<sup>2</sup>)

- 퀵 정렬의 핵심 이론
  - 기준값을 중심으로 계속 데이터를 2개의 집합으로 나누면서 정렬하는 것이 핵심

- 퀵 정렬 과정
   1. 데이터를 분할하는 기준 값을 설정함
   2. 기준값을 기준으로 다음 a~e 과정을 거쳐 데이터를 2개의 집합으로 분리함
      a. start가 가리키는 데이터가 기준값이 가리키는 데이터보다 작으면 start를 오른쪽으로 1칸 이동
      b. end가 가리키는 데이터가 기준값이 가리키는 데이터보다 크면 end를 왼쪽으로 1칸 이동
      c. start가 가리키는 데이터가 기준값이 가리키는 데이터보다 크고 end가 가리키는 데이터가 기준값이 가리키는 데이터보다 작으면 start, end가 가리키는 데이터를 swap하고 start는 오른쪽, end는 왼쪽으로 1칸씩 이동
      d. start와 end가 만날 때까지 a~c를 반복함
      e. start와 end가 만나면 만난 지점에서 가리키는 데이터와 기준값이 가리키는 데이터를 비교하여 기준값이 가리키는 데이터가 크면 만난 지점의 오른쪽에, 작으면 만난 지점의 왼쪽에 기준값이 기리키는 데이터를 삽입함
   3. 분리 집합에서 다시 기준값을 선정함
   4. 분리 집합이 1개 이하가 될 때까지 과정 1~3을 반복함
   
- 퀵 정렬의 시간 복잡도는 비교적 준수하여 코딩 테스트에서도 종종 응용함
  - 재귀 함수의 형태로 직접 구현해보셈
