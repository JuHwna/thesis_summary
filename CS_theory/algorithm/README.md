# 1. 자료구조
## 1. 배열과 리스트
### 배열
- 배열 : 메모리의 연속 공간에 값이 채워져 있는 형태의 자료구조
- 배열의 특징 
   1. 인덱스를 사용하여 값에 바로 접근할 수 있음
   2. 새로운 값을 삽입하거나 특정 인덱스에 있는 값을 삭제하기 어려움. 값을 삽입하거나 삭제하려면 해당 인덱스 주변에 있는 값을 이동시키는 과정이 필요함
   3. 배열의 크기는 선언할 때 지정할 수 있으며 한 번 선언하면 크기를 늘리거나 줄일 수 없음
   4. 구조 간단
   
### 리스트
- 리스트 : 값과 포인터를 묶은 노드라는 것을 포인터로 연결한 자료구조
  - 노드 : 컴퓨터 과학에서 값, 포인터를 쌍으로 갖는 기초 단위를 부르는 말
- 리스트의 특징
   1. 인덱스가 없으므로 값에 접근하려면 head 포인터부터 순서대로 접근해야 함 (값에 접근하는 속도가 느리다.)
   2. 포인터로 연결되어 있으므로 데이터를 삽입하거나 삭제하는 연산속도가 빠름
   3. 선언할 때 크기를 별도롤 지정하지 않아도 됨. 리스트의 크기는 정해져 있지 않으며 크기가 변하기 쉬운 데이터를 다룰 때 적절함
   4. 배열보다 구조가 복잡함(포인터를 저장할 공간이 필요해서)
   
> 파이썬에서는 배열과 리스트를 구분하지 않음

## 2. 구간 합
- 구간 합 : 합 배열을 이용하여 시간 복잡도를 더 줄이기 위해 사용하는 특수한 목적의 알고리즘
- 합 배열 S를 만드는 공식 : S[i]=S[i-1]+A[i]
- 구간 합을 구하는 공식 : S[j]-S[i-1]
- 2차원 구간 D[i][j]의 값을 채우는 구간 합 공식
  - D[i][j] = D[i][j-1]+D[i-1][j]-D[i-1][j-1]+A[i][j]
- X<sub>1</sub>, Y<sub>1</sub>, X<sub>2</sub>, Y<sub>2</sub>에 대한 답을 구간 합으로 구하는 방법
  - D[X2][Y2]-D[X1-1][Y2]-D[X2][Y1-1]+D[X1-1][Y1-1]
  
## 3. 투포인터
- 투포인터 : 2개의 포인터로 알고리즘의 시간 복잡도를 최적화함
- 투포인터 이동 원칙
  - sum > N: sum=sum-start_index; start_index++;
  - sum < N: end_index++; sum=sum+end_index;
  - sum== N: end_index++; sum=sum+end_index; count++;
  
## 4. 슬라이딩 윈도우
- 슬라이딩 윈도우 알고리즘 : 2개의 포인터로 범위를 지정한 다음, 범위를 유지한 채로 이동하여 문제를 해결함


## 5. 스택과 큐
- 스택과 큐 : 리스트에서 조금 더 발전한 형태의 자료구조

### 스택과 큐의 핵심 이론
#### 스택
- 스택 : 삽입과 삭제 연산이 후입선출로 이뤄지는 자료구조
  - 후입선출 : 삽입과 삭제가 한 쪽에서만 일어나는 특징이 있음
    - 가장 마지막에 넣었던 값이 나오게 되는 것
    - 후입선출 개념 자체가 재귀 함수 알고리즘 원리와 일맥상통함
  - **깊이 우선 탐색**, **백트래킹 종류**의 코딩 테스트에 효과적임
  
- 파이썬의 스택(리스트로 구현할 수 있음)
  - 위치
    - top : 삽입과 삭제가 일어나는 위치를 뜻함
  - 연산(리스트 이름이 s일때)
    - s.append(data) : top 위치에 새로운 데이터를 삽입하는 연산
    - s.pop() : top 위치에 현재 있는 데이터를 삭제하고 확인하는 연산
    - s[-1] : top 위치에 현재 있는 데이터를 단순 확인하는 연산

#### 큐
- 큐: 삽입과 삭제 연산이 선입선출로 이뤄지는 자료구조
  - 스택과 다르게 먼저 들어온 데이터가 먼저 나감
  - 삽입과 삭제가 양방향에서 이뤄짐
  - 너비 우선 탐색에서 자주 사용
  
- 파이썬의 큐(deque를 이용)
  - 위치
    - rear : 큐에서 가장 끝 데이터를 가리키는 영역
    - front : 큐에서 가장 앞의 데이터를 가리키는 영역
  - 연산(리스트 이름이 s일때)
    - s.append(data) : rear 부분에 새로운 데이터를 삽입하는 연산
    - s.popleft() : front 부분에 있는 데이터를 삭제하고 확인하는 연산
    - s[0] : 큐의 맨 앞(front)에 있는 데이터를 확인할 때 사용하는 연산
 
~~~
우선순위 큐도 있음
- 우선순위 큐: 값이 들어간 순서와 상관 없이 우선순위가 높은 데이터가 먼저 나오는 자료구조
  - 큐 설정에 따라 front에 항상 최댓값과 최솟값이 위치함
  - 일반적으로 힙을 이용해 구현
  - 힙은 트리 종류 중 하나
~~~  


# 2. 정렬

|정렬 알고리즘|정의|
|------------|----|
|버블(bubble)|데이터의 인접 요소끼리 비교하고 swap 연산을 수행하며 정렬하는 방식|
|삽입(selection)|대상에서 가장 크거나 작은 데이터를 찾아가 선택을 반복하면서 정렬하는 방식|
|삽입(insertion)|대상을 선택해 정렬된 영역에서 선택 데이터의 적절한 위치를 찾아 삽입하면서 정렬하는 방식|
|퀵(quick)|pivot 값을 선정해 해당 값을 기준으로 정렬하는 방식|
|병합(merge)|이미 정렬된 부분 집합들을 효율적으로 병합해 전체를 정렬하는 방식|
|기수(radix)|데이터의 자릿수를 바탕으로 비교해 데이터를 정렬하는 방식|

## 1. 버블 정렬
- 버블 정렬 : 두 인접한 데이터의 크기를 비교해 정렬하는 방법
  - 시간 복잡도 : O(n<sup>2</sup>)-> 다른 정렬 알고리즘보다 속도가 느린 편
  - 루프를 돌면서 인접한 데이터 간의 swap 연산으로 정렬함
- 버블 정렬 과정
   1. 비교 연산이 필요한 루프 범위를 설정함
   2. 인접한 데이터 값을 비교함
   3. swap 조건에 부합하면 swap 연산을 수행함
   4. 루프 범위가 끝날 때까지 2,3을 반복함
   5. 정렬 영역을 설정한다. 다음 루프를 실행할 때는 이 영역을 제외함
   6. 비교 대상이 없을 때까지 1~5를 반복함
   
## 2. 선택 정렬
- 선택 정렬 : 대상 데이터에서 최대나 최소 데이터를 데이터가 나열된 순으로 찾아가며 선택하는 방법
  - 구현 방법이 복잡
  - 시간 복잡도 : O(n<sup>2</sup>) -> 효율적이지 않아 코딩 테스트에서는 사용하지 않음

- 선택 정렬의 핵심 이론
  - 최솟값 또는 최댓값을 찾고 남은 정렬 부분의 가장 앞에 있는 데이터와 swap하는 것이 핵심
  
- 선택 정렬 과정
   1. 남은 정렬 부분에서 최솟값 또는 최댓값을 찾음
   2. 남은 정렬 부분에서 가장 앞에 있는 데이터와 선택된 데이터를 swap함
   3. 가장 앞에 있는 데이터의 위치를 변경해 남은 정렬 부분의 범위를 축소함
   4. 전체 데이터 크기만큼 index가 커질 때까지, 즉 남은 정렬 부분이 없을 때까지 반복함.
   

## 3. 삽입 정렬
- 삽입 정렬 : 이미 정렬된 데이터 범위에 정렬되지 않은 데이터를 적절한 위치에 삽입시켜 정렬하는 방식
  - 시간 복잡도 : O(n<sup>2</sup>) -> 느린 편이지만 구현하기 쉬움

- 삽입 정렬의 핵심 이론 : 선택 데이터를 현재 정렬된 데이터 범위 내에서 적절한 위치에 삽입하는 것이 핵심

- 삽입 정렬 수행 방식
   1. 현재 index에 있는 데이터 값을 선택함
   2. 현재 선택한 데이터가 정렬된 데이터 범위에 삽입될 위치를 탐색함
   3. 삽입 위치부터 index에 있는 위치까지 shift 연산을 수행함
   4. 삽입 위치에 현재 선택한 데이터를 삽입하고 index++ 연산을 수행함
   5. 전체 데이터의 크기만큼 index가 커질 때까지, 즉 선택할 데이터가 없을 때까지 반복함
 
 - 적절한 삽입 위치를 탐색하는 부분에서 이진 탐색 등과 같은 탐색 알고리즘을 사용하면 시간 복잡도를 줄일 수 있음
 
 ## 4. 퀵 정렬
 - 퀵 정렬 : 기준값(pivot)을 선정해 해당 값보다 작은 데이터와 큰 데이터로 분류하는 것을 반복해 정렬하는 알고리즘
   - 기준값이 어떻게 선정되는지가 시간 복잡도에 많은 영향을 미침
     - 평균적인 시간 복잡도 : O(nlogn)
     - 최악의 경우의 시간 복잡도 : O(n<sup>2</sup>)

- 퀵 정렬의 핵심 이론
  - 기준값을 중심으로 계속 데이터를 2개의 집합으로 나누면서 정렬하는 것이 핵심

- 퀵 정렬 과정
   1. 데이터를 분할하는 기준 값을 설정함
   2. 기준값을 기준으로 다음 a~e 과정을 거쳐 데이터를 2개의 집합으로 분리함


      a. start가 가리키는 데이터가 기준값이 가리키는 데이터보다 작으면 start를 오른쪽으로 1칸 이동
      
      b. end가 가리키는 데이터가 기준값이 가리키는 데이터보다 크면 end를 왼쪽으로 1칸 이동
      
      c. start가 가리키는 데이터가 기준값이 가리키는 데이터보다 크고 end가 가리키는 데이터가 기준값이 가리키는 데이터보다 작으면 start, end가 가리키는 데이터를 swap하고 start는 오른쪽, end는 왼쪽으로 1칸씩 이동
      
      d. start와 end가 만날 때까지 a~c를 반복함
      
      e. start와 end가 만나면 만난 지점에서 가리키는 데이터와 기준값이 가리키는 데이터를 비교하여 기준값이 가리키는 데이터가 크면 만난 지점의 오른쪽에, 작으면 만난 지점의 왼쪽에 기준값이 기리키는 데이터를 삽입함
   3. 분리 집합에서 다시 기준값을 선정함
   4. 분리 집합이 1개 이하가 될 때까지 과정 1~3을 반복함
   
- 퀵 정렬의 시간 복잡도는 비교적 준수하여 코딩 테스트에서도 종종 응용함
  - 재귀 함수의 형태로 직접 구현해보셈

## 5. 병합 정렬
- 병합 정렬 : 분할 정복 방식을 사용해 데이터를 분할하고 분할한 집합을 정렬하며 합치는 알고리즘
  - 분할 정복 방식 : 주어진 문제를 작은 사례로 나누고 각각의 작은 문제들을 해결하여 정복하는 방법
  - 시간 복잡도 : O(nlogn)

- 병합 정렬의 핵심 이론
  - 가장 작은 데이터 집합으로 분할
  - 병합하면서 정렬한다

- 병합 정렬 수행 방식
   1. 42, 32, 24, 60, 15, 5, 90, 45
   2. [42], [32], [24], [60], [15], [5], [90], [45]
   3. [32,42], [24,60], [5,15], [45,90]
   4. [24,32,42,60], [5,15,45,90]
   5. [5,15,24,32,42,45,60,90]

- 병합 정렬은 코딩 테스트의 정렬 관련 문제에서 자주 등장함

- 2개의 그룹을 병합하는 과정
  - 투 포인터 개념을 사용하여 왼쪽, 오른쪽 그룹을 병합함
  - 왼쪽 포인터와 오른쪽 포인터의 값을 비교하여 작은 값을 결과 배열에 추가하고 포인터를 오른쪽으로 1칸 이동시킴
  - 반드시 숙지 필요
  

## 6. 기수 정렬
- 기수 정렬 : 값을 비교하지 않는 특이한 정렬
  - 값을 놓고 비교할 자릿수를 정한 다음 해당 자릿수만 비교함
  - 시간 복잡도 : O(kn) -> k는 데이터의 자릿수를 말함

- 기수 정렬의 핵심 이론
  - 10개의 큐를 이용함
  - 각 큐는 값의 자릿수를 대표함
  - (ex) 일의 자릿수를 기준으로 데이터 저장 후 데이터 정렬 -> 십의 자릿수를 기준으로 데이터 저장 후 데이터 저장
    - 원본 배열 : 16, 80, 18, 77, 03, 24, 88, 23
    - 일의 자릿수 기준으로 배열 원소를 큐에 집어넣음
    - 0번째 큐부터 9번째 큐까지 pop을 진행함
    - 결과 : 80, 03, 23, 24, 16, 77, 18, 88
    - 십의 자릿수를 기준으로 같은 과정을 진행함
    - 마지막 자릿수를 기준으로 정렬할 때까지 앞의 과정 반복

- 기수 정렬은 시간 복잡도가 가장 짧은 정렬임
  - 코딩 테스트에서 정렬해야 하는 데이터의 개수가 너무 많으면 기수 정렬 알고리즘 활용


# 3. 탐색
- 주어진 데이터에서 자신이 원하는 데이터를 찾아내는 알고리즘

## 1. 깊이 우선 탐색(DFS: depth-first search)
- 깊이 우선 탐색 : 그래프 완전 탐색 기법 중 하나
  - 그래의 시작 노드에서 출발하여 탐색할 한 쪽 분기를 정하여 최대 깊이까지 탐색을 마친 후 다른 쪽 분기로 이동하여 다시 탐색을 수행하는 알고리즘
  
|기능|특징|시간 복잡도(노드 수 :V, 에지 수:E)|
|----|---|--------------------------------|
|그래프 완전 탐색|재귀 함수로 구현, 스택 자료구조 이용|O(V+E)|

- 실제 구현 시 재귀 함수를 이용함 -> 스택 오버플로에 유의해야 함
  - 스택 오버플로 : 지정한 스택 메모리 사이즈보다 더 많은 스택 메모리를 사용하게 되어 에러가 발생하는 상황
- 깊이 웅선 탐색을 응용하여 풀 수 있는 문제 : 단절점 찾기, 단절선 찾기, 사이클 찾기, 위상 정렬 등

- **깊이 우선 탐색의 핵심 이론**
  - 한 번 방문한 노드를 다시 방문하면 안 되므로 노드 방문 여부를 체크할 리스트가 필요함
  - 그래프는 인접 리스트로 표현함
  - 탐색 방식 : 후입선출 특성을 가지므로 스택을 사용하여 설명함
     1. DFS를 시작할 노드를 정한 후 사용할 자료구조 초기화하기
       - DFS를 위해 필요한 초기 작업 : 인접 리스트로 그래프 표현하기, 방문 리스트 초기화하기, 시작 노드 스택에 삽입하기
     2. 스택에서 노드를 꺼낸 후 꺼낸 노드의 인접 노드를 다시 스택에 삽입하기
       - POP을 수행하여 노드를 꺼내고 꺼낸 노드를 탐색 순서에 기입하고 인접 리스트의 인접 노드를 스택에 삽입하여 방문 리스트를 체크함
     3. 스택 자료구조에 값이 없을 때까지 반복하기
       - 앞선 과정을 스택 자료구조에 값이 없을 때까지 반복함
       - 이미 다녀간 노드는 방문 리스트를 바탕으로 재삽입하지 않는 것이 핵심
  - 문제 풀때는 재귀 함수로 구현함
  

## 2. 너비 우선 탐색(BFS: breadth-first search
- 너비 우선 탐색 : 그래프를 완전 탐색하는 방법 중 하나
  - 시작 노드에서 출발해 시작 노드를 기준으로 가까운 노드를 먼저 방분하면서 탐색하는 알고리즘
  
|기능|특징|시간 복잡도(노드 수: V, 에지 수: E)|
|----|---|---------------------------------|
|그래프 완전 탐색| FIFO 탐색, Queue 자료구조 이용|O(V+E)|

- 선입선출 방식으로 탐색하므로 큐를 이용해 구현해야함
- 탐색 시작 노드와 가까운 노드를 우선하여 탐색하므로 목표 노드에 도착하는 경로가 여러 개일 때 최단 경로를 보장함

- **너비 우선 탐색의 핵심 이론**
   1. BFS를 시작할 노드를 정한 후 사용할 자료구조 쵝화하기
      - DFS와 마찬가지로 방문했던 노드는 다시 방문하지 않으므로 방문한 노드를 체크하기 위한 리스트가 필요함
      - 그래프를 인접 리스트로 표현하는 것도 DFS와 동일함
      - 차이점 : 탐색을 위해 스택이 아닌 큐를 사용함
      - 시작 노드를 큐에 삽입하며 방문 리스트를 체크한 것을 보여줌
   2. 큐에서 노드를 꺼낸 후 꺼낸 노드의 인접 노드를 다시 큐에 삽입하기
      - 큐에서 노드를 꺼내면서 인접 노드를 큐에 삽입함
      - 이때 방문 리스트를 체크하여 이미 방문한 노드는 큐에 삽입하지 않음
      - 큐에서 꺼낸 노드는 탐색 순서에 기록함
   3. 큐 자료구조에 값이 없을 때까지 반복하기
      - 큐에 노드가 없을 때까지 앞선 과정을 반복함


## 3. 이진 탐색
- 이진 탐색 : 데이터가 정렬돼 있는 상태에서 원하는 값을 찾아내는 알고리즘
  - 대상 데이터의 중앙값과 찾고자 하는 값을 비교해 데이터의 크기를 절반씩 줄이면서 대상을 찾음

|기능|특징|시작 복잡도|
|----|---|-----------|
|타깃 데이터 탐색|중앙값 비교를 통한 대상 축소 방식|O(logN)|

- 정렬 데이터에서 원하는 데이터를 탐색할 때 사용하는 가장 일반적인 알고리즘
- 구현 및 원리가 비교적 간단하므로 많은 코딩 테스트에서 부분 문제로 요구하는 영역


- 이진 탐색의 핵심 이론 : 오름 차순으로 정렬된 데이터에서 다음 4가지 과정을 반복함
  - 이진 탐색 과정
     1. 현재 데이터셋의 중앙값을 선택함
     2. 중앙값>타깃 데이터일 때 중앙값 기준으로 왼쪽 데이터셋을 선택함
     3. 중앙값<타깃 데이터일 때 중앙값 기준으로 오른쪽 데이터셋을 선택함
     4. 과정1~3을 반복하다가 중앙값 == 타깃 데이터일 때 탐색을 종료함


# 4. 그리디
- 그리디 알고리즘 : 현재 상태에서 볼 수 있는 선택지 중 최선의 선택을 하는 알고리즘
  - 동적 계획법보다 구현하기 쉽고 시작 복잡도가 우수함
  - but, 단점: 항상 최적의 해를 보장하지 못함
  - 코딩 테스트에서 그리디 알고리즘을 사용하기 전에는 항상 그리디 알고리즘을 적용할 때의 논리 유무를 충분히 살펴야함
  
## 1. 그리디 알고리즘
- 그리디 알고리즘 : 현재 상태애ㅔ서 보는 선택지 중 최선의 선택지가 전체 선택지 중 최선의 선택지라고 가정하는 알고리즘

- 그리디 알고리즘의 핵심 이론
  - 그리디 알고리즘 수행 과정
     1. 해 선택 : 현재 상태에서 가장 최선이라고 생각되는 해를 선택한다
     2. 적절성 검사 : 현재 선택한 해가 전체 문제의 제약 조건에 벗어나지 않는지 검사한다.
     3. 해 검사 : 현재까지 선택한 해 집합이 전체 문제를 해결할 수 있는지 검사함. 전체 문제를 해결하지 못한다면 1로 돌아가 같은 과정을 반복함.


- 그리디 알고리즘에서 자주 사용하는 자료구조 우선순위 큐
  - 현재 상황에서 최선의 선택을 반복하는 알고리즘이기 때문에 우선순위 큐를 사용하여 문제를 해결하는 경우가 흔함
  - 파이썬에서는 우선순위 큐 자료구조를 두 가지 방법으로 제공함(PriorityQueue, heapq)
    - PriorityQueue : 객체 자체를 우선순위 큐 형태로 만들어 사용
      - from queue import PriorityQueue
    - heapq : 기본적인 list 객체를 대상으로 원소 삽입, 삭제(꺼내기) 등의 제공 함수를 통해 우선순위 큐를 구현함
      - import heapq
    - 두 개의 모듈 모두 생각보다 강력하고 다양하게 응용할 수 있음

# 5. 정수론
- 수학에서 정수론은 수의 성질을 탐구하고 공부하는 분야를 뜻함
- 코딩테스트에서는 모든 정수론의 분야가 나오지 않음 -> 가장 많이 등장하는 소수 부분과 호제법 부분을 집중적으로 다룸

## 1. 소수 구하기
- 소수 : 자신보다 작은 2개의 자연수를 곱해 만들 수 없는 1보다 큰 자연수
  - 1과 자기 자신 외에 약수가 존재하지 않는 수

- 소수 구하기의 핵심 이론
  - 대표적인 판별법 : 에라토스네테스의 체

- **에라토스테네스의 체 원리**
   1. 구하고자 하는 소수의 범위만큼 1차원 리스트를 생성함
   2. 2부터 시작하고 현재 숫자가 지워진 상태가 아닌 경우 현재 선택된 숫자의 배수에 해당하는 수를 리스트에서 끝까지 탐색하면서 지운다. 이때 처음으로 선택된 숫자는 지우지 않음
   3. 리스트의 끝까지 2를 반복한 후 리스트에서 남아 있는 모든 수를 출력함
   
- 에라토스테네스의 체를 사용할 때 시간 복잡도는?
  - 구현 시, 이중 for문을 이용하므로 시간 복잡도 : O(N<sup>2</sup>)
  - but, 실제 시간 복잡도는 최적화의 정도에 따라 다르겠지만 일반적으로 O(Nlog(logN))임
    - 이유 : 배수를 삭제하는 연산으로 실제 구현에서 바깥쪽 for문을 생략하는 경우가 빈번하게 발생하기 때문임
    
- N의 제곱근까지만 탐색하는 이유
  - N의 제곱근이 n일 때 N=a\*b를 만족하는 a와 b가 모두 n보다 클 수는 없음
  - N보다 작은 수 간운데 소수가 아닌 수는 항상 n보다 작은 약수를 가짐
  - 에라토스테네스의 체로 n이하의 수의 배수를 모두 제거하면 1부터 N 사이의 소수를 구할 수 있음

## 2. 오일러 피
- 오일러 피 함수 P[N] : 1부터 N까지 범위에서 N과 서로소인 자연수의 개수를 뜻함

- 오일러 피의 핵심 이론
   1. 구하괒 하는 오일러 피의 범위만큼 리스트를 자기 자신의 인덱스값으로 초기화함.
   2. 2부터 시작해 현재 리스트의 값과 인덱스가 같으면(=소수일 때) 현재 선택된 숫자(K)의 배수에 해당하는 수를 리스트에 끝까지 탐색하며 P[i]=P[i]-P[i]/K 연산을 수행함(i는 K의 배수)
   3. 리스트의 끝까지 2를 반복하여 오일러 피 함수를 완성함

## 3. 유클리드 호제법
- 유클리드 호제법 : 두 수의 최대 공약수를 구하는 알고리즘
  - 일반적으로 최대 공약수를 구하는 방법 : 소인수 분해를 이용한 공통된 소수들의 곱으로 표현
  - 유클리드 호제법은 좀 더 간단한 방법을 제시

- 유클리드 호제법의 핵심 이론
  - MOD 연산이 최대 공약수를 구하는데 사용하는 핵심 연산임

|연산|기능|예제|
|----|----|----|
|MOD|두 값을 나눈 나머지를 구하는 연산|10 MOD 4 = 2|

- MOD 연산을 이해하면 유클리드 호제법을 구현할 수 있음
- MOD 연산으로 구현하는 유클리드 호제법
   1. 큰 수를 작은 수로 나누는 MOD 연산을 수행함
   2. 앞 단계에서의 작은 수와 MOD 연산 결괏값(나머지)으로 MOD 연산을 수행함.
   3. 단계 2를 반복하다가 나머지가 0이 되는 순간의 작은 수를 최대 공약수로 선택함. (분모가 최대 공약수가 된다)

- 최소 공배수 " 두수의 곱을 최대 공약수로 나눈 값

## 4. 확장 유클리드 호제법
- 확장 유클리드 호제법 : 방정식의 해를 구하는 것

- 확장 유클리드 호제법의 핵심 이론
  - 해를 구하고자 하는 방정식  : ax + by = c(a,b,c,x,y는 정수)
    - 이때 위 방정식은 c%gcd(a,b) = 0인 경우에만 정수해를 가짐
    - c가 a와 b의 최대 공약수의 배수인 경우에만 정수해를 가짐
    - ax + by= c가 정수해를 갖게 하는 c의 최솟값이 gcd(a,b)라는 것을 의미
    
    
- 확장 유클리드 호제법의 원리 이해하기
  - 5x + 9y = 2일 때 이 식을 만족하는 정수 x,y를 구하기
     1. 우선 5x + 9y가 정수해를 갖게 하는 c의 최솟값이 gcd(5,9)라는 것을 적용하여 식을 다시 놓음. gcd(5,9)=1이므로 5x + 9y = 1로 식을 다시 놓고 다음 단계 진행
     2. a,b로 유클리드 호제법을 반복 실행하며 몫, 나머지를 저장함. 반복은 나머지가 0이 되면 중단함
     
     |유클리드 호제법 실행|나머지|몫|
     |------------------|------|--|
     |5%9=5|5|0|
     |9%5=4|4|1|
     |5%4=1|1|1|
     |4$1=0|0|4|
     
     
     
# 6. 그래프
- 그래프 : 노드와 에지로 구성된 집합
  - 노드 : 데이터를 표현하는 단위
  - 에지 : 노드를 연결함
  
## 1. 그래프의 표현

~~~
- 2차원 리스트 생성
  - 0으로 초기화한 행 개수 3, 열 개수 4인 2차원 리스트를 생성하는 법
    - 리스트로 객체를 생성하는 방법 -> 추천!
      - A=[[0 for col in range(4)] for row in range(3)]
      
    - 얕은 복사를 일으켜 생성하는 방법
      - A=[[0]*4]*3
      - 원리 : 리스트 객체 1개를 생성하고 모든 리스트 3개의 각 요소가 해당 객체를 바라봄
~~~

- 그래프를 구현하는 3가지 방법
1. 에지 리스트
  - 에지를 중심으로 그래프를 표현함
  - 리스트에 출발 노드, 도착 노드를 저장하여 에지를 표현함
  - 또는 출발 노드, 도착 노드, 가중치를 저장하여 가중치가 있는 에지를 표현함
  - **에지 리스트로 가중치 없는 그래프 표현하기**
    - 가중치가 없는 그래프 : 출발 노드와 도착 노드만 표현하므로 리스트의 열은 2개면 충분함
      - EX) 1에서 2로 뻗어나가는 에지는 [1,2]로 표현함, 4에서 5로 뻗어나가는 에지는 [4,5]로 표현함
        - 이처럼 방향이 있는 그래프는 순서에 맞게 노드를 리스트에 저장하는 방식으로 표현함
        - 에지 리스트 : 노드를 리스트에 저장하여 에지를 표현하니깐 이렇게 불리는 거임
  - **에지 리스트로 가중치 있는 그래프 표현하기**
    - 가중치가 있는 그래프 : 열을 3개로 늘려 3번째 열에 가중치를 저장하면 됨
      - EX) 1에서 2로 향하는 가중치가 8인 에지는 [1,2,8]로 표현함
  
  - BUT, 특정 노드와 관련되어 있는 에지를 탐색하기는 쉽지 않음
    - 사용하는 곳 : 노드 사이의 최단 거리를 구하는 벨만-포드나 최소 신장 트리를 찾는 크루스칼 알고리즘에 사용함
    - 노드 중심 알고리즘에는 잘 사용하지 않음

2. 인접 행렬
  - 2차원 리스트를 자료구조로 이용하여 그래프를 표현함
  - 에지 리스트와 다르게 노드 중심으로 그래프를 표현함
  - **인접 행렬로 가중치 없는 그래프 표현하기**
    - EX) 1에서 2를 향하는 에지를 인접 행렬은 1행 2열에 1을 저장하는 방식으로 표현함
      - 1을 저장하는 이유 : 가중치가 없기 때문
      - 1에서 2로 향하는 에지가 있다는 표시를 노드 중심으로 함
  - **인접 행렬로 가중치 있는 그래프 표현하기**
    - EX) 2에서 5로 향하는 에지의 가중치를 2행 5열에 기록함
  - 장점 : 두 노드를 연결하는 에지의 여부와 가중치값은 리스트에 직접 접근하면 바로 확인 가능
  - 단점 
    - 시간 복잡도가 인접 리스트에 비해 느림 : 노드와 관련되어 있는 에지를 탐색하려면 N번 접근해야 함
    - 공간 효율성이 떨어질 수 있음: 노드 개수에 비해 에지가 적을 때

3. 인접 리스트
  - 파이썬의 리스트를 이용하여 그래프를 표현함
  - 노드 개수만큼 리스트를 선언함
  - 리스트의 input data 형태 : 문제의 조건에 맞게 설정함
  - **인접 리스트로 가중치 없는 그래프 표현하기**
    - int 데이터 하나로 그래프를 표현하기에 충분
    - N번 노드와 연결되어 있는 노드를 리스트의 index N에 연결된 노드 개수만큼 리스트에 append하는 방식으로 표현함
    - EX) 노드 1과 연결된 2,3 노드는 A[1]에 [2,3]을 연결하는 방식으로 표현함
    
  - **인접 리스트로 가중치 있는 그래프 표현하기**
    - 가중치가 있는 경우 input data를 2개(도착 노드, 가중치)로 사용함
    - EX) A[1]에 [(2,8),(3,3)]이 연결되어 있음
      - 노드 1과 2가 가중치 8 에지로, 노드 1과 3일 가중치 3에지로 연결되어 있음
    - 방향성도 고려되었음
    - 장점 
      - 노드와 연결된 에지를 탐색하는 시간은 매우 뛰어남
      - 노드 개수가 커도 공간 효율이 좋아 메모리 초과 에러도 발생하지 않음
      - 실제 코딩 테스트에서는 인접 리스트를 이용한 그래프 구현을 선호함
    - 단점
      - 그래프를 구현하는 다른 방법에 비해 인접 리스트를 이용한 그래프 구현은 복잡한 편
      

## 2. 유니온 파인드
- 유니온 파인드
  - 일반적으로 여러 노드가 있을 때 특정 2개의 노드를 연결해 1개의 집합으로 묶는 union 연산과 두 노드가 같은 집합에 속해 있는지를 확인하는 find 연산으로 구성되어 있는 알고리즘
  
- 유니온 파인드의 핵심 이론
  - union, find 연산을 완벽히 이해하는 것이 핵심
  - union, find 연산
    - union 연산 : 각 노드가 속한 집합을 1개로 합치는 연산
      - 노드 a,b가 a∈A, b∈B일 때 union(a,b)는 A∪B를 말함
    - find 연산 : 특정 노드 a에 관해 a가 속한 집합의 대표 노드를 반환하는 연산
      - 노드 a가 a∈A일 때 find(a)는 A 집합의 대표 노드를 반환함
 
 - 유니온 파인드의 원리 이해하기
   - 유니온 파인드 알고리즘 구현 방법
      1. 유니온 파인드를 표현하는 일반적인 방법 : 1차원 리스트를 이용하는 것
         - 처음에는 노드가 연결되어 있지 않으므로 각 노드가 대표 노드가 됨
         - 각 노드가 모두 대표 노드이므로 리스트는 자신의 인덱스값으로 초기화함
         
         |1|2|3|4|5|6|
         |-|-|-|-|-|-|
         |1|2|3|4|5|6|
         
      2. 2개의 노드를 선택해 각각의 대표 노드를 찾아 연결하는 union 연산을 수행함
         - 리스트를 보면 1,4와 5,6을 union 연산으로 연결함
         - 리스트[4]는 1로, 리스트[6]은 5로 업데이트함
         - 업데이트하는 것의 의미
           - 1,4의 연결을 예로 들어 설명하면 1은 대표 노드, 4는 자식 노드로 union 연산을 하므로 리스트[4]의 대표 노드를 1로 설정한 것
           - 자식 노드로 들어가는 노드값 4를 대표 노드값 1로 변경한 것
           - 그 결과 각각의 집합이었던 1,4는 하나로 합쳐짐
         
         - union(1,4)
         - union(5,6)
         
         |1|2|3|4|5|6|
         |-|-|-|-|-|-|
         |1|2|3|1|5|5|
         
         - union(4,6)
         
         |1|2|3|4|5|6|
         |-|-|-|-|-|-|
         |1|2|3|1|1|5|
       
       3. find 연산은 자신이 속한 집합의 대표 노드를 찾는 연산
          - find 연산은 단순히 대표 노드를 찾는 역할만 하는 것이 아니라 그래프를 정돈하고 시간 복잡도를 줄임
          - find 연산의 작동 원리
             1. 대상 노드 리스트에 index값과 value값이 동일한지 확인함
             2. 동일하지 않으면 value 값이 가리키는 index 위치로 이동함
             3. 이동 위치의 index 값과 value 값이 같을 때까지 1~2를 반복함. 반복이므로 이 부분은 재귀 함수로 구현함
             4. 대표 노드에 도달하면 재귀 함수를 빠져나오면서 거치는 모든 노드값을 대표 노드 값으로 변경함
          - 시간 복잡도가 줄어드는 효과를 얻게 됨
          - 연산을 할 때 거치는 노드들이 대표 노드와 바로 연결되는 현태로 변경됨
            - 이렇게 되면 추후 노드와 관련된 find 연산 속도가 O(1)로 변경됨
          - 한 번의 find 연산을 이용해 모든 노드가 루트 노드에 직접 연결되는 형태로 변경되는 것을 볼 수 있음
            - 이러한 형태로 변경되면 이후 find 연산이 진행될 때 경로 압축의 효과가 나타남
          - **경로 압축**
            - 실제 그래프에서 여러 노드를 거쳐야 하는 경로에서 그래프를 변형해 더 짧은 경로로 갈 수 있도록 함으로써 시간 복잡도를 효과적으로 줄이는 방법 


## 3. 위상 정렬
- 위상 정렬 : 사이클이 없는 방향 그래프에서 노드 순서를 찾는 알고리즘

|기능|특징|시간 복잡도(노드 수: V, 에지 수:E)|
|---|----|--------------------------------|
|노드 간의 순서를 결정|사이클이 없어야 함|O(V+E)|

  - 위상 정렬에서는 항상 유일한 값으로 정렬되지 않음
  - 사이클이 존재하면 노드 간의 순서를 명확하게 정의할 수 없으므로 위상 정렬을 적용할 수 없음
  
- 위상 정렬의 핵심 이론

1. 진입 차수를 이해하기
  - 진입 차수 : 자기 자신을 가리키는 에지의 개수
    - EX) 진입 차수 리스트 D를 다음과 같이 업데이트함. 1에서 2,3,을 가리키고 있으므로 D[2], D[3]을 각각 1만큼 증가시키게 됨
      - 인접 리스트에 기반을 둔 진입 차수 리스트는 다음과 같이 만들 수 있음
      
      |1|2|3|4|5|
      |0|1|1|2|2|
      
2. 진입 차수 리스트에서 진입 차수가 0인 노드를 선택하고 선택된 노드를 정렬 리스트에 저장함
   - 그 후 인접 리스트에서 선택된 노드가 가리키는 노드들의 진입 차수를 1씩 뺌
   
      |1|2|3|4|5|
      |0|0|0|2|2|
      
   - 계속해서 다음 노드 2를 선택하여 반복함. 이 과정은 모든 노드가 정렬될 때까지 반복함. 
   - 여기서 진입 차수가 0인 노드를 3을 먼저 선택했다면 3이 우선 위상 정렬 리스트에 들어갈 것임
   - 진입 차수가 0인 노드를 무엇을 선택할지에 따라 결과가 달라지므로 위상 정렬이 늘 같은 정렬 결과를 보장하지 않는다고 말했던 것이 바로 이런 경우임
   

## 4. 다익스트라
- 다익스트라 알고리즘 : 그래프에서 최단 거리를 구하는 알고리즘

|기능|특징|시간 복잡도(노드 수: V, 에지 수:E)|
|----|---|--------------------------------|
|출발 노드와 모든 노드 간의 최단 거리 탐색|에지는 모두 양수|O(ElogV)|

